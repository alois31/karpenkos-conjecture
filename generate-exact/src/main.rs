// SPDX-FileCopyrightText: Alois Wohlschlager <wohlschlager@math.lmu.de>
// SPDX-License-Identifier: EUPL-1.2

use std::{
    borrow::Cow,
    cmp::Reverse,
    collections::HashSet,
    fs::File,
    io::{BufWriter, Write},
};

fn main() {
    let n = std::env::args()
        .nth(1)
        .expect("missing argument")
        .parse::<u32>()
        .expect("invalid number");

    let d = n * (n + 1) / 2;
    assert!(n <= 31);
    assert!(d <= 31);

    let directory = format!("results/ogr{n}");
    std::fs::create_dir_all(&directory).unwrap();
    let mut stage1_writer =
        BufWriter::new(File::create(format!("{directory}/stage1.sing")).unwrap());

    writeln!(
        stage1_writer,
        "ring T = (0,v1,v2,v3,v4),t,ls;
poly l = t+1/2*v1*t^2+(1/4*v1^3+1/2*v2)*t^4+(1/8*v1^7+1/4*v1^4*v2+1/4*v1*v2^2+1/2*v3)*t^8+(1/16*v1^15+1/8*v1^12*v2+1/8*v1^9*v2^2+1/4*v1^8*v3+1/8*v1^3*v2^4+1/4*v2^5+1/4*v1*v3^2+1/2*v4)*t^16;
poly e = t-1/2*v1*t^2+1/2*v1^2*t^3+(-7/8*v1^3-1/2*v2)*t^4+(13/8*v1^4+3/2*v1*v2)*t^5+(-49/16*v1^5-7/2*v1^2*v2)*t^6+(97/16*v1^6+17/2*v1^3*v2+v2^2)*t^7+(-1615/128*v1^7-683/32*v1^4*v2-47/8*v1*v2^2-1/2*v3)*t^8+(3457/128*v1^8+1701/32*v1^5*v2+175/8*v1^2*v2^2+5/2*v1*v3)*t^9+(-15059/256*v1^9-2101/16*v1^6*v2-1133/16*v1^3*v2^2-11/4*v2^3-33/4*v1^2*v3)*t^10+(33311/256*v1^10+2599/8*v1^7*v2+1747/8*v1^4*v2^2+97/4*v1*v2^3+97/4*v1^3*v3+3*v2*v3)*t^11+(-298779/1024*v1^11-206401/256*v1^8*v2-20839/32*v1^5*v2^2-1001/8*v1^2*v2^3-273/4*v1^4*v3-91/4*v1*v2*v3)*t^12+(677425/1024*v1^12+513051/256*v1^9*v2+60417/32*v1^6*v2^2+2065/4*v1^3*v2^3+1491/8*v1^5*v3+35/4*v2^4+105*v1^2*v2*v3)*t^13+(-3100153/2048*v1^13-1276797/256*v1^10*v2-343305/64*v1^7*v2^2-30585/16*v1^4*v2^3-7965/16*v1^6*v3-825/8*v1*v2^4-795/2*v1^3*v2*v3-15*v2^2*v3)*t^14+(7150065/2048*v1^14+3181831/256*v1^11*v2+1923287/128*v1^8*v2^2+106147/16*v1^5*v2^3+20977/16*v1^7*v3+5461/8*v1^2*v2^4+5465/4*v1^4*v2*v3+155*v1*v2^2*v3+2*v3^2)*t^15+(-265683199/32768*v1^15-254085183/8192*v1^12*v2-85266969/2048*v1^9*v2^2-1406631/64*v1^6*v2^3-1752131/512*v1^8*v3-441523/128*v1^3*v2^4-283203/64*v1^5*v2*v3-977/32*v2^5-14841/16*v1^2*v2^2*v3-155/8*v1*v3^2-1/2*v4)*t^16+(620778889/32768*v1^16+634847609/8192*v1^13*v2+234196817/2048*v1^10*v2^2+8998647/128*v1^7*v2^3+4544755/512*v1^9*v3+1924179/128*v1^4*v2^4+439641/32*v1^6*v2*v3+14379/32*v1*v2^5+69255/16*v1^3*v2^2*v3+285/4*v2^3*v3+873/8*v1^2*v3^2+9/2*v1*v4)*t^17+(-2916549343/65536*v1^17-396997305/2048*v1^14*v2-1277328295/4096*v1^11*v2^2-224175965/1024*v1^8*v2^3-23466995/1024*v1^10*v3-15300985/256*v1^5*v2^4-2646415/64*v1^7*v2*v3-116147/32*v1^2*v2^5-564395/32*v1^4*v2^2*v3-7505/8*v1*v2^3*v3-7695/16*v1^3*v3^2-95/4*v2*v3^2-95/4*v1^2*v4)*t^18+(6884081619/65536*v1^18+1988150143/4096*v1^15*v2+432864055/512*v1^12*v2^2+683554535/1024*v1^9*v2^3+60376315/1024*v1^11*v3+57069865/256*v1^6*v2^4+31129045/256*v1^8*v2*v3+696391/32*v1^3*v2^5+2112495/32*v1^5*v2^2*v3+1811/16*v2^6+6930*v1^2*v2^3*v3+29665/16*v1^4*v3^2+1165/4*v1*v2*v3^2+395/4*v1^3*v4+5*v2*v4)*t^19+(-65274337849/262144*v1^19-79730231287/65536*v1^16*v2-4671068927/2048*v1^13*v2^2-4098174927/2048*v1^10*v2^3-309867145/2048*v1^12*v3-811651379/1024*v1^7*v2^4-359671851/1024*v1^9*v2*v3-28047635/256*v1^4*v2^5-29800617/128*v1^6*v2^2*v3-127589/64*v1*v2^6-618079/16*v1^3*v2^3*v3-420651/64*v1^5*v3^2-5313/16*v2^4*v3-8085/4*v1^2*v2*v3^2-5775/16*v1^4*v4-231/4*v1*v2*v4)*t^20+(155329973139/262144*v1^20+200017596405/65536*v1^17*v2+25097929659/4096*v1^14*v2^2+757078971/128*v1^11*v2^3+396788755/1024*v1^13*v3+695144571/256*v1^8*v2^4+128033939/128*v1^10*v2*v3+126135933/256*v1^5*v2^5+100537899/128*v1^7*v2^2*v3+1215665/64*v1^2*v2^6+5850119/32*v1^4*v2^3*v3+1406933/64*v1^6*v3^2+85261/16*v1*v2^4*v3+85261/8*v1^3*v2*v3^2+19481/16*v1^5*v4+759/4*v2^2*v3^2+759/2*v1^2*v2*v4)*t^21+(-741850490151/524288*v1^21-502199460197/65536*v1^18*v2-134370087399/8192*v1^15*v2^2-35383397639/2048*v1^12*v2^3-2029224703/2048*v1^14*v3-9248026369/1024*v1^9*v2^4-360434357/128*v1^11*v2*v3-131018419/64*v1^6*v2^5-327790641/128*v1^8*v2^2*v3-16883541/128*v1^3*v2^6-49807029/64*v1^5*v2^3*v3-9018001/128*v1^7*v3^2-14007/32*v2^7-1502751/32*v1^2*v2^4*v3-1533479/32*v1^4*v2*v3^2-124361/32*v1^6*v4-22701/8*v1*v2^2*v3^2-7613/4*v1^3*v2*v4-23/2*v3^3-69/2*v2^2*v4)*t^22+(1777170918439/524288*v1^22+1261890508587/65536*v1^19*v2+1434328007307/32768*v1^16*v2^2+102323443697/2048*v1^13*v2^3+5182550607/2048*v1^15*v3+30025109577/1024*v1^10*v2^4+4020329211/512*v1^12*v2*v3+256532103/32*v1^7*v2^5+1040248359/128*v1^9*v2^2*v3+12078271/16*v1^4*v2^6+98390175/32*v1^6*v2^3*v3+13990515/64*v1^8*v3^2+286893/32*v1*v2^7+9770523/32*v1^3*v2^4*v3+6219573/32*v1^5*v2*v3^2+381273/32*v1^7*v4+12309/8*v2^5*v3+188187/8*v1^2*v2^2*v3^2+65349/8*v1^4*v2*v4+331/2*v1*v3^3+981/2*v1*v2^2*v4+6*v3*v4)*t^23+(-34158179977955/4194304*v1^23-50769330799415/1048576*v1^20*v2-30538361812375/262144*v1^17*v2^2-146678782525/1024*v1^14*v2^3-423147655825/65536*v1^16*v3-764354934525/8192*v1^11*v2^4-88977381275/4096*v1^13*v2*v3-61392386315/2048*v1^8*v2^5-25839188375/1024*v1^10*v2^2*v3-972132135/256*v1^5*v2^6-1470458925/128*v1^7*v2^3*v3-338646425/512*v1^9*v3^2-12588875/128*v1^2*v2^7-211325075/128*v1^4*v2^4*v3-93839525/128*v1^6*v2*v3^2-2268175/64*v1^8*v4-1865825/64*v1*v2^5*v3-9276475/64*v1^3*v2^2*v3^2-2029625/64*v1^5*v2*v4-20475/16*v2^3*v3^2-21125/16*v1^2*v3^3-62075/16*v1^2*v2^2*v4-325/4*v1*v3*v4)*t^24+(82286527987677/4194304*v1^24+127748125931049/1048576*v1^21*v2+81080234353287/262144*v1^18*v2^2+3339001511937/8192*v1^15*v2^3+1078853651421/65536*v1^17*v3+2391401773761/8192*v1^12*v2^4+122253007383/2048*v1^14*v2*v3+221222741025/2048*v1^9*v2^5+78795478593/1024*v1^11*v2^2*v3+4460440257/256*v1^6*v2^6+10521087291/256*v1^8*v2^3*v3+1004304639/512*v1^10*v3^2+49687911/64*v1^3*v2^7+252680337/32*v1^5*v2^4*v3+167665563/64*v1^7*v2*v3^2+13182117/128*v1^9*v4+111735/64*v2^8+2390661/8*v1^2*v2^5*v3+23894325/32*v1^4*v2^2*v3^2+918099/8*v1^6*v2*v4+362817/16*v1*v2^3*v3^2+125307/16*v1^3*v3^3+366093/16*v1^3*v2^2*v4+819/4*v2*v3^3+819/4*v2^3*v4+2457/4*v1^2*v3*v4)*t^25+(-397428815245839/8388608*v1^25-160824339805323/524288*v1^22*v2-429629192406957/524288*v1^19*v2^2-151020044993331/131072*v1^16*v2^3-5497986418305/131072*v1^18*v3-14748190581087/16384*v1^13*v2^4-668039465637/4096*v1^15*v2*v3-773321542335/2048*v1^10*v2^5-473360730381/2048*v1^12*v2^2*v3-38195882163/512*v1^7*v2^6-72709254639/512*v1^9*v2^3*v3-5860662309/1024*v1^11*v3^2-637864209/128*v1^4*v2^7-4428644031/128*v1^6*v2^4*v3-2298520125/256*v1^8*v2*v3^2-75214089/256*v1^10*v4-5214411/128*v1*v2^8-71161335/32*v1^3*v2^5*v3-54635175/16*v1^5*v2^2*v3^2-12614859/32*v1^7*v2*v4-57015/8*v2^6*v3-1754109/8*v1^2*v2^3*v3^2-310779/8*v1^4*v3^3-226233/2*v1^4*v2^2*v4-27783/8*v1*v2*v3^3-27783/8*v1*v2^3*v4-27783/8*v1^3*v3*v4-189/2*v2*v3*v4)*t^26+(961933844902331/8388608*v1^26+50646062813465/65536*v1^23*v2+568056262390449/262144*v1^20*v2^2+424427811838457/131072*v1^17*v2^3+14002628462193/131072*v1^19*v3+44909887252055/16384*v1^14*v2^4+14529382076363/32768*v1^16*v2*v3+2635573254643/2048*v1^11*v2^5+1403725343713/2048*v1^13*v2^2*v3+309844434795/1024*v1^8*v2^6+61053166139/128*v1^10*v2^3*v3+16871988735/1024*v1^12*v3^2+3554163585/128*v1^5*v2^7+18166461677/128*v1^7*v2^4*v3+7620655931/256*v1^9*v2*v3^2+211424297/256*v1^11*v4+64684123/128*v1^2*v2^8+433668697/32*v1^4*v2^5*v3+458960467/32*v1^6*v2^2*v3^2+83261059/64*v1^8*v2*v4+1245811/8*v1*v2^6*v3+12400255/8*v1^3*v2^3*v3^2+684313/4*v1^5*v3^3+1990009/4*v1^5*v2^2*v4+31465/4*v2^4*v3^2+128905/4*v1^2*v2*v3^3+128905/4*v1^2*v2^3*v4+65975/4*v1^4*v3*v4+3045/2*v1*v2*v3*v4)*t^27+(-9332626508059427/33554432*v1^27-16341062047320833/8388608*v1^24*v2-5998492702546897/1048576*v1^21*v2^2-2373300242127793/262144*v1^18*v2^3-17824759271267/65536*v1^20*v3-541053545138839/65536*v1^15*v2^4-157319506927503/131072*v1^17*v2*v3-70329074474219/16384*v1^12*v2^5-16468267641333/8192*v1^14*v2^2*v3-4812388574255/4096*v1^9*v2^6-1602227192805/1024*v1^11*v2^3*v3-192117958655/4096*v1^13*v3^2-8936976081/64*v1^6*v2^7-566179085663/1024*v1^8*v2^4*v3-6148887603/64*v1^10*v2*v3^2-2348670763/1024*v1^12*v4-2288085355/512*v1^3*v2^8-9226374969/128*v1^5*v2^5*v3-7233227241/128*v1^7*v2^2*v3^2-1064848419/256*v1^9*v2*v4-912485/128*v2^9-58268685/32*v1^2*v2^6*v3-288673395/32*v1^4*v2^3*v3^2-22148663/32*v1^6*v3^3-64428633/32*v1^6*v2^2*v4-2584625/16*v1*v2^4*v3^2-876525/4*v1^3*v2*v3^3-876525/4*v1^3*v2^3*v4-558279/8*v1^5*v3*v4-4495/2*v2^2*v3^3-4495/4*v2^4*v4-13485*v1^2*v2*v3*v4)*t^28+(22680399900405497/33554432*v1^28+41212697581156491/8388608*v1^25*v2+15811335534722595/1048576*v1^22*v2^2+3302375157265275/131072*v1^19*v2^3+181468381567905/262144*v1^21*v3+3227821025434225/131072*v1^16*v2^4+106059175133535/32768*v1^18*v2*v3+230289854423741/16384*v1^13*v2^5+47841441437175/8192*v1^15*v2^2*v3+18026780731443/4096*v1^10*v2^6+10304301674975/2048*v1^12*v2^3*v3+541726767465/4096*v1^14*v3^2+166321171015/256*v1^7*v2^7+2116029509175/1024*v1^9*v2^4*v3+155276143815/512*v1^11*v2*v3^2+6457851645/1024*v1^13*v4+16287232445/512*v1^4*v2^8+22233988485/64*v1^6*v2^5*v3+54222899025/256*v1^8*v2^2*v3^2+1659406905/128*v1^10*v2*v4+23884415/128*v1*v2^9+488797615/32*v1^3*v2^6*v3+1471909605/32*v1^5*v2^3*v3^2+84091685/32*v1^7*v3^3+244978275/32*v1^7*v2^2*v4+264585/8*v2^7*v3+28613775/16*v1^2*v2^4*v3^2+9830875/8*v1^4*v2*v3^3+9833355/8*v1^4*v2^3*v4+2175735/8*v1^6*v3*v4+88195/2*v1*v2^2*v3^3+88815/4*v1*v2^4*v4+87885*v1^3*v2*v3*v4+155/2*v3^4+930*v2^2*v3*v4)*t^29+(-110437762213668361/67108864*v1^29-103990722514598025/8388608*v1^26*v2-83238280769207219/2097152*v1^23*v2^2-36607962754811467/524288*v1^20*v2^3-923527493285823/524288*v1^22*v3-19091963896730199/262144*v1^17*v2^4-570093482639913/65536*v1^19*v2*v3-371030634971501/8192*v1^14*v2^5-551302797782025/32768*v1^16*v2^2*v3-131046307609787/8192*v1^11*v2^6-65148252986233/4096*v1^13*v2^3*v3-3030329369641/8192*v1^15*v3^2-5823103805285/2048*v1^8*v2^7-15286243650993/2048*v1^10*v2^4*v3-1924402588939/2048*v1^12*v2*v3^2-35216938401/2048*v1^14*v4-199336224149/1024*v1^5*v2^8-198876610523/128*v1^7*v2^5*v3-390528379987/512*v1^9*v2^2*v3^2-10128988763/256*v1^11*v2*v4-330424195/128*v1^2*v2^9-6637376675/64*v1^4*v2^6*v3-6819759409/32*v1^6*v2^3*v3^2-1215596273/128*v1^8*v3^3-3549524459/128*v1^8*v2^2*v4-13095919/16*v1*v2^7*v3-457331871/32*v1^3*v2^4*v3^2-96723441/16*v1^5*v2*v3^3-96816193/16*v1^5*v2^3*v4-15948043/16*v1^7*v3*v4-365459/8*v2^5*v3^2-1872555/4*v1^2*v2^2*v3^3-1895743/8*v1^2*v2^4*v4-1895867/4*v1^4*v2*v3*v4-5921/4*v1*v3^4-17453*v1*v2^2*v3*v4-62*v3^2*v4)*t^30+(269334674396373265/67108864*v1^30+262517759073547379/8388608*v1^27*v2+437653171924906931/4194304*v1^24*v2^2+101070058385638873/524288*v1^21*v2^3+2349597013211259/524288*v1^23*v3+56031210495850971/262144*v1^18*v2^4+3055258036442619/131072*v1^20*v2*v3+1178851414329927/8192*v1^15*v2^5+1576577795969813/32768*v1^17*v2^2*v3+232133519446989/4096*v1^12*v2^6+101465460495597/2048*v1^14*v2^3*v3+16832507064199/16384*v1^16*v3^2+24253311150455/2048*v1^9*v2^7+53659975999709/2048*v1^11*v2^4*v3+5868950783841/2048*v1^13*v2*v3^2+95348799801/2048*v1^15*v4+1091465374453/1024*v1^6*v2^8+3354510657631/512*v1^8*v2^5*v3+1360996725149/512*v1^10*v2^2*v3^2+60754880385/512*v1^12*v2*v4+3235405873/128*v1^3*v2^9+38913062067/64*v1^5*v2^6*v3+29383484097/32*v1^7*v2^3*v3^2+4223586557/128*v1^9*v3^3+12368543971/128*v1^9*v2^2*v4+1897553/64*v2^10+43007943/4*v1^2*v2^7*v3+2972457971/32*v1^4*v2^4*v3^2+27049737*v1^6*v2*v3^3+27108642*v1^6*v2^3*v4+111464657/32*v1^8*v3*v4+8545729/8*v1*v2^5*v3^2+14394699/4*v1^3*v2^2*v3^3+14630335/8*v1^3*v2^4*v4+8993391/4*v1^5*v2*v3*v4+19635*v2^3*v3^3+61153/4*v1^2*v3^4+11789/2*v2^5*v4+177837*v1^2*v2^2*v3*v4+1126*v1*v3^2*v4+4*v4^2)*t^31;
proc coeffs_t(poly p) {{
    matrix m = coeffs(p,t);
    matrix n[31][1] = m[2..nrows(m),1];
    return(n);
}}
proc al_tusi(poly p, matrix series, ideal J) {{
    poly x = 0;
    for (int i=nrows(series); i>0; i--) {{
        x = reduce(p*x+series[i,1],J);
    }}
    return(reduce(p*x,J));
}}
matrix l_ = coeffs_t(l);
matrix e_ = coeffs_t(e);
matrix b = coeffs_t(al_tusi(-l,e_,t^32));
matrix d = coeffs_t(al_tusi(2*l,e_,t^32));
ring R = (0,v1,v2,v3,v4),cs(1..{n}),ws(1..{n});
option(redSB);
matrix l_ = fetch(T,l_);
matrix e_ = fetch(T,e_);
matrix b = fetch(T,b);
matrix d = fetch(T,d);",
    ).unwrap();
    for i in 1..=31 {
        writeln!(stage1_writer, "poly b({i}) = b[{i},1];").unwrap();
    }
    writeln!(stage1_writer, "poly cs(0) = 1;").unwrap();
    for i in n + 1..=31 {
        writeln!(stage1_writer, "poly cs({i}) = 0;").unwrap();
    }

    // Step 1: compute expressions for the Chern classes of the dual
    let mut known_monomial_symmetric_functions = HashSet::new();
    writeln!(stage1_writer, "poly c(0) = 1;").unwrap();
    for i in 1..=n {
        let ci = (i..=d)
            .flat_map(|w| partitions(w, i))
            .map(|j| {
                j.iter()
                    .map(|part| format!("b({part})"))
                    .chain(std::iter::once(define_monomial_symmetric_function(
                        n,
                        &j,
                        &mut known_monomial_symmetric_functions,
                        &mut stage1_writer,
                    )))
                    .collect::<Vec<_>>()
                    .join("*")
            })
            .collect::<Vec<_>>()
            .join("+");
        writeln!(stage1_writer, "poly c({i}) = {ci};").unwrap();
    }

    // Step 2: compute the Chern subalgebra
    writeln!(stage1_writer, "ideal I =").unwrap();
    for k in (1..=n).rev() {
        writeln!(
            stage1_writer,
            "  {},",
            ((2 * k).saturating_sub(n)..=u32::min(n, 2 * k))
                .map(|i| format!("cs({i})*c({})", 2 * k - i))
                .collect::<Vec<_>>()
                .join("+"),
        )
        .unwrap();
    }
    writeln!(
        stage1_writer,
        "  cs({n})^2;
I = std(I);",
    )
    .unwrap();

    // Step 3: write the next stage, which will compute the cohomology ring
    writeln!(
        stage1_writer,
        "print(\"ring R = (0,v1,v2,v3,v4),z(1..{n}),ws(1..{n});
option(redSB);\");",
    )
    .unwrap();
    for i in 1..=31 {
        writeln!(stage1_writer, "printf(\"poly d({i}) = %s;\",d[{i},1]);").unwrap();
    }
    for i in 1..=n {
        writeln!(
            stage1_writer,
            "print(\"poly cs({i}) = (-1)^{i}*({});\");",
            (0..=(n - i))
                .map(|k| format!("d({})*z({})", k + 1, k + i))
                .collect::<Vec<_>>()
                .join("+"),
        )
        .unwrap();
    }
    writeln!(stage1_writer, "print(\"ideal I =\");").unwrap();
    for i in 1..=n {
        writeln!(
            stage1_writer,
            "printf(\"  cs({i})^2-(%s),\",reduce(cs({i})^2,I));",
        )
        .unwrap();
    }
    writeln!(
        stage1_writer,
        "print(\"  0;
I = std(I);\");",
    )
    .unwrap();
    for i in 1..=31 {
        writeln!(
            stage1_writer,
            "poly p({i}) = {};",
            (1..i)
                .map(|j| format!("(-1)^{}*cs({j})*p({})", j - 1, i - j))
                .chain(std::iter::once(format!("(-1)^{}*{i}*cs({i})", i - 1)))
                .collect::<Vec<_>>()
                .join("+")
        )
        .unwrap();
    }
    writeln!(
        stage1_writer,
        "poly lu = reduce(({})/2,I);
poly u = al_tusi(lu,e_,I);
printf(\"poly u = reduce(%s,I);\",u);",
        (1..=31)
            .map(|i| format!("l_[{i},1]*p({i})"))
            .collect::<Vec<_>>()
            .join("+"),
    )
    .unwrap();
    writeln!(stage1_writer, "quit;").unwrap();

    let mut stage3_writer =
        BufWriter::new(File::create(format!("{directory}/stage3.sing")).unwrap());
    writeln!(
        stage3_writer,
        "< \"{directory}/stage2.sing\";
poly x;",
    )
    .unwrap();
    for mask in 0..1 << (n - 1) {
        let is = (2..=n)
            .filter(|i| mask & (1 << (i - 2)) != 0)
            .collect::<Vec<_>>();
        for d1 in 0..=d - is.iter().sum::<u32>() {
            writeln!(stage3_writer, "x = 1;").unwrap();
            for factor in std::iter::repeat_n(Cow::Borrowed("u"), d1.try_into().unwrap())
                .chain(is.iter().map(|i| Cow::Owned(format!("cs({i})"))))
                .rev()
            {
                writeln!(stage3_writer, "x = reduce({factor}*x,I);").unwrap();
            }
            writeln!(
                stage3_writer,
                "printf(\"{}=%s\",x);",
                std::iter::once(format!("u^{d1}"))
                    .chain(is.iter().map(|i| format!("cs({i})")))
                    .collect::<Vec<_>>()
                    .join("*"),
            )
            .unwrap();
        }
    }
    writeln!(stage3_writer, "quit;").unwrap();
}

fn partitions(weight: u32, length: u32) -> Vec<Vec<u32>> {
    if length == 1 {
        vec![vec![weight]]
    } else {
        (1..=weight - length + 1)
            .flat_map(|i| {
                partitions(weight - i, length - 1)
                    .into_iter()
                    .filter_map(move |j| (j[0] <= i).then(|| std::iter::once(i).chain(j).collect()))
            })
            .collect()
    }
}

fn define_monomial_symmetric_function(
    n: u32,
    j: &[u32],
    known: &mut HashSet<Vec<u32>>,
    writer: &mut dyn Write,
) -> String {
    let name = format!(
        "m({})",
        j.iter()
            .map(|part| format!("{part}"))
            .collect::<Vec<_>>()
            .join(",")
    );
    if !known.contains(j) {
        if j.len() > n as usize {
            writeln!(writer, "poly {name} = 0;").unwrap();
        } else if j[0] == 1 {
            writeln!(writer, "poly {name} = cs({});", j.len()).unwrap();
        } else {
            let jr = j
                .iter()
                .filter_map(|part| (*part > 1).then_some(part - 1))
                .collect::<Vec<_>>();
            let mjr = define_monomial_symmetric_function(n, &jr, known, writer);
            let m_neighbours = neighbours(&jr, j.len())
                .into_iter()
                .filter(|jn| jn != j)
                .map(|jn| {
                    format!(
                        "{}*{}",
                        neighbour_multiplicity(&jn, &jr),
                        define_monomial_symmetric_function(n, &jn, known, writer),
                    )
                })
                .collect::<Vec<_>>()
                .join("+");
            writeln!(
                writer,
                "poly {name} = reduce(cs({})*{mjr}-({m_neighbours}),cs({n})^2);",
                j.len(),
            )
            .unwrap();
        }
        known.insert(j.to_owned());
    }
    name
}

fn neighbours(jr: &[u32], k: usize) -> HashSet<Vec<u32>> {
    if jr.is_empty() {
        HashSet::from_iter([vec![1; k]])
    } else {
        neighbours(&jr[1..], k - 1)
            .into_iter()
            .map(|jn| std::iter::once(jr[0] + 1).chain(jn).collect())
            .chain(neighbours(&jr[1..], k).into_iter().map(|jn| {
                let mut result = std::iter::once(jr[0]).chain(jn).collect::<Vec<_>>();
                result.sort_by_key(|part| Reverse(*part));
                result
            }))
            .collect()
    }
}

fn neighbour_multiplicity(jn: &[u32], jr: &[u32]) -> u32 {
    do_neighbour_multiplicity(
        jn,
        &jr.iter()
            .copied()
            .chain(std::iter::repeat_n(0, jn.len() - jr.len()))
            .collect::<Vec<_>>(),
    )
}

fn do_neighbour_multiplicity(jn: &[u32], jr: &[u32]) -> u32 {
    if jn.is_empty() {
        1
    } else {
        assert!(jn[0] == jr[0] || jn[0] == jr[0] + 1);
        let lead_n = jn.iter().take_while(|part| **part == jn[0]).count();
        let lead_r = jr.iter().take_while(|part| **part == jr[0]).count();
        if jn[0] > jr[0] {
            assert!(lead_n <= lead_r);
            neighbour_multiplicity(&jn[lead_n..], &jr[lead_n..])
        } else {
            assert!(lead_n >= lead_r);
            assert!((lead_r..lead_n).all(|i| jn[i] == jr[i] + 1));
            binom(lead_n as u32, lead_r as u32)
                * neighbour_multiplicity(&jn[lead_n..], &jr[lead_n..])
        }
    }
}

fn binom(n: u32, k: u32) -> u32 {
    if k == 0 {
        1
    } else {
        n * binom(n - 1, k - 1) / k
    }
}
